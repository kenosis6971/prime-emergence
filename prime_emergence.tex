\documentclass[12pt]{article}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{geometry}
\geometry{margin=1in}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{cite}
% --- Theorem environments ---
\usepackage{amsthm}

% Number theorems within sections (optional). Remove [section] if you prefer global numbering.
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}[theorem]{Definition}

\theoremstyle{definition}

\theoremstyle{remark}
\newtheorem*{remark}{Remark} % unnumbered

\title{The Prime Odometer:\\A Generative Law for Prime Emergence in Prime Exponent Space}
\author{Kenneth Hilton\thanks{Email: kenosis@gmail.com}}

\date{August 2025}

\begin{document}
\maketitle
\begin{abstract}
Primes have long been defined negatively---as numbers with no divisors---and generated catalogically by sieves of elimination. We introduce the \textit{Prime Odometer}, a constructive successor law in Prime Exponent Space (PE-space) where primes arise not by rejection but by structural inevitability. At each tick $n \mapsto n+1$, the odometer updates the prime-exponent vector $\sigma(n)$ incrementally via $p$-adic carries. When redistribution fails, the successor vector is forced to a one-hot state $(0,0,\dots,0,1)$, certifying primality without external verification. We prove correctness by induction, show that the odometer enumerates primes in order, and contrast this generative sieve with Eratosthenes’ eliminative sieve. This reframing provides a new theoretical lens: primes are the \textit{canonical carries} of arithmetic, inevitable and positively generative.
\end{abstract}

%--------

\section{Introduction}

Prime numbers, the indivisible atoms of arithmetic, have been studied for millennia yet remain
mysterious in their distribution. Traditionally they are defined \emph{negatively}---as numbers greater
than one with no divisors other than one and themselves. This absence-based definition has shaped
centuries of number theory: primality is confirmed only by elimination of factors. Classical
algorithms mirror this stance. The Sieve of Eratosthenes, for example, marks off composites to leave
primes behind; modern primality tests probe for divisors or verify properties of multiplicative
groups. In every case, primes are treated as the remainder after composites are discarded.

We propose a new, constructive view: primes can be generated \emph{positively} as inevitable events in
\textit{Prime Exponent Space} (PE-space). In this representation, each integer $n$ is encoded by its
vector of prime exponents,
\[
\sigma(n) = (e_1, e_2, e_3, \dots), \qquad n = \prod_i p_i^{\,e_i},
\]
a sparse coordinate system induced by the Fundamental Theorem of Arithmetic. Arithmetic operations
become vector operations, and the successor map $n \mapsto n+1$ can be studied as a geometric
transition through this lattice.

Our central thesis is that successor steps in PE-space behave like an odometer. Each prime
axis $p$ carries its own residue counter $r_p(n) \equiv n \pmod p$. When $n$ advances to $n+1$,
each counter increments:
\[
r_p(n+1) = (r_p(n)+1) \bmod p.
\]
If a counter wraps to zero, then $p \mid (n+1)$ and the exponent of $p$ in the factorization
of $n+1$ is at least one. More generally, if $n \equiv -1 \pmod{p^t}$, then a carry of depth $t$
occurs, and the valuation is determined exactly:
\[
\nu_p(n+1) = t.
\]
In words: the depth of the $p$-adic carry is the exponent of $p$ in $n+1$. For most steps,
redistribution across existing axes suffices. But at special thresholds---exactly the primes---all
existing axes fail to absorb the increment. The odometer is forced to roll over into a new axis,
and $\sigma(n+1)$ becomes one-hot, $(0,0,\dots,0,1)$. This canonical carry is the generative
certificate of primality.

We call this mechanism the \textbf{Prime Odometer}. Unlike sieves of elimination, it is a
\emph{generative sieve}: it produces primes sequentially as structural necessities of counting,
rather than as residues after testing. The Prime Odometer offers:
\begin{itemize}
    \item A \emph{constructive definition of primality}: primes are numbers whose successor vectors are forced one-hot.
    \item A \emph{proof by induction}: maintaining residues for all known primes, the algorithm correctly generates $\sigma(n)$ for all $n$ and identifies primes without external verification.
    \item A \emph{dual to Eratosthenes}: whereas the classical sieve eliminates composites, the odometer constructs successors, and primes appear inevitably as carries.
\end{itemize}

This paper develops the Prime Odometer formally. Section~2 introduces the necessary preliminaries in
PE-space and $p$-adic carry depth. Section~3 defines the odometer algorithm. Section~4 states and
proves the Odometer Theorem by induction. Section~5 compares this constructive sieve with classical
approaches. Sections~6 and~7 explore implications and open questions, and Section~8 concludes. An
appendix provides pseudocode for implementation. The result is both a new algorithm and a new
conceptual lens: primes as the canonical carries of arithmetic.

\paragraph{Remark.}
The Prime Odometer was first developed here independently, without reference to prior
art on trial-division sieves. Subsequent literature review revealed its algorithmic
equivalence to classical incremental trial division~\cite{hardywright,crandallpomerance}.
The originality of this work lies in its \emph{structural reframing}: primes are interpreted
as canonical carries in PE-space, providing a constructive law and a positive definition
of primality.

A companion manuscript develops a heuristic, predictive detector in PE-space that anticipates carry events; the present paper focuses on the constructive law itself.

%--------

\section{Preliminaries}

We begin by establishing the framework of Prime Exponent Space (PE-space) and the successor
carry law that underlies the Prime Odometer.

\subsection{Prime Exponent Space}

Let $p_1 = 2 < p_2 = 3 < p_3 = 5 < \cdots$ denote the ordered primes. Every integer $n \geq 2$
has a unique prime factorization
\[
n = \prod_{i \geq 1} p_i^{\,e_i(n)},
\]
where all but finitely many exponents $e_i(n)$ are zero. The \emph{prime exponent vector} of $n$ is
\[
\sigma(n) = (e_1(n), e_2(n), e_3(n), \dots),
\]
a sparse coordinate in the infinite-dimensional lattice $\mathbb{N}_0^{(\infty)}$. By the
Fundamental Theorem of Arithmetic, the map $n \mapsto \sigma(n)$ is bijective.

In this representation, multiplication and division become vector addition and subtraction,
respectively:
\[
\sigma(ab) = \sigma(a) + \sigma(b), \qquad \sigma\!\left(\tfrac{a}{b}\right) = \sigma(a) - \sigma(b).
\]

\subsection{Smooth Frontiers}

For $k \geq 1$, define the \emph{$p_k$-smooth semigroup}
\[
S_k = \Bigl\{ \prod_{i=1}^k p_i^{\,e_i} : e_i \in \mathbb{N}_0 \Bigr\},
\]
the set of integers whose prime factors are bounded by $p_k$. The integers $S_k$ form a frontier:
they are all representable using only the first $k$ axes of PE-space.

A number $n \in S_k$ is called a \emph{pre-prime at level $k$} if its successor $n+1 \notin S_k$.
The emergence threshold theorem states:
\[
p_{k+1} = \min(\mathbb{N}_{\geq 2} \setminus S_k), \qquad p_{k+1}-1 \in S_k.
\]
Thus the step $p_{k+1}-1 \mapsto p_{k+1}$ is the minimal exit from $S_k$: the canonical carry that
forces creation of the new axis $p_{k+1}$.

\subsection{$p$-adic Carry Depth}

The odometer rule is governed by $p$-adic valuation. For a prime $p$, define
\[
d_p(n) = \max \{ t \geq 0 : n \equiv -1 \pmod{p^t} \}.
\]
This is the \emph{carry depth} of $p$ at $n$. Then the valuation of $p$ in $n+1$ is exactly
\[
\nu_p(n+1) = d_p(n).
\]

In words: when incrementing $n$ by $1$, the exponent of $p$ in $n+1$ is given by the depth of the
carry chain produced in the $p$-adic expansion of $n$. This generalizes the familiar notion of
trailing digits in base-$B$: in base $10$, the number of trailing $9$s in $n$ is the depth of the
carry chain when incremented to $n+1$.

\subsection{Canonical Carry}

From these definitions we can state the canonical carry law: along the successor map $n \mapsto
n+1$, if redistribution across the first $k$ prime axes is impossible, then a new axis must appear.
Formally:
\[
n \in S_k, \quad n+1 \notin S_k \quad \Rightarrow \quad \sigma(n+1) = (0,0,\dots,0,1).
\]
That is, $n+1$ is prime, and its PE-vector is one-hot on the new axis $p_{k+1}$. This is the
structural inevitability on which the Prime Odometer is built.

%--------
\section{The Prime Odometer Algorithm}

Having established the structural framework of PE-space and the canonical carry law, we now
define the Prime Odometer as an explicit algorithm. Its state evolves incrementally, ensuring that
$\sigma(n)$ and the primality of $n+1$ can be determined without refactoring from scratch.

\subsection{State Representation}

At integer $n$, the odometer maintains:

\begin{itemize}
  \item A list $P = \{p_1, p_2, \dots, p_k\}$ of all discovered primes, with $p_k^2 \geq n$.
  \item Residue counters $r_p(n) \equiv n \pmod{p}$ for each $p \in P$.
  \item (Optional) Higher-power residues $r_{p^t}(n) \equiv n \pmod{p^t}$ for small $t$, enabling
        direct computation of valuations $\nu_p(n+1)$.
\end{itemize}

This state is finite: to certify primality of $m=n+1$, only primes up to $\sqrt{m}$ are needed.

\subsection{Successor Update Rule}

To advance from $n$ to $m=n+1$:

\begin{enumerate}
  \item For each $p \in P$, update the residue
  \[
  r_p(m) = (r_p(n)+1) \bmod p.
  \]

  \item If $r_p(m)=0$ for some $p \in P$, then $p \mid m$. Repeatedly test higher powers
        $p^t$ (using $r_{p^t}$ if tracked) to determine $\nu_p(m)$.

  \item If no $p \in P$ with $p \leq \sqrt{m}$ divides $m$, then $m$ is prime. Append $m$ to $P$,
        initialize its residue $r_m(m)=0$, and record $\sigma(m)=(0,0,\dots,0,1)$ as a one-hot vector.
\end{enumerate}

\subsection{Interpretation}

The odometer ``ticks'' in synchrony with the successor map:

\begin{itemize}
  \item Most steps redistribute mass across existing axes: $m$ factors into known primes.
  \item At primes, redistribution fails: all counters miss, and a new axis is forced.
  \item The new prime appears as a canonical carry, exactly like $999 \to 1000$ in a positional odometer.
\end{itemize}

\subsection{Algorithmic Character}

The Prime Odometer is thus:

\begin{itemize}
  \item \textbf{Generative:} it constructs $\sigma(n+1)$ from $\sigma(n)$ incrementally.
  \item \textbf{Deterministic:} no probabilistic tests are required.
  \item \textbf{Factor-free:} it never re-factors $m=n+1$; only small modular counters are updated.
  \item \textbf{Sequential:} primes emerge as inevitable events along the counting trajectory.
\end{itemize}

The contrast with classical sieves is sharp: Eratosthenes marks composites to reveal primes,
while the odometer advances successors until a new axis is forced, revealing primes as structural
necessities of PE-space.

%--------
\section{The Odometer Theorem}

We now formalize the correctness of the Prime Odometer. The theorem states that the odometer
generates the exact prime-exponent vector $\sigma(n)$ for every $n$, and that primes emerge
precisely as canonical carries.

\begin{theorem}[Prime Odometer Correctness]
Initialize with $\sigma(2) = (1,0,0,\dots)$ and residue counters
$r_p(2) \equiv 2 \pmod{p}$ for $p=2$. At each successor step $n \mapsto n+1$, update residues
as described in Section~3. Then:
\begin{enumerate}
  \item For all $n \geq 2$, the odometer state correctly represents $\sigma(n)$.
  \item If $m=n+1$ is composite, then $\sigma(m)$ is determined exactly by the residue wraps
        of primes $p \leq \sqrt{m}$.
  \item If $m=n+1$ is prime, then $\sigma(m) = (0,0,\dots,0,1)$: a one-hot vector on a new axis.
        Thus the odometer identifies primes without external verification.
\end{enumerate}
\end{theorem}

\begin{proof}[Proof sketch]
We proceed by induction on $n$.

\emph{Base case.} At $n=2$, the state is initialized with $\sigma(2)=(1,0,0,\dots)$ and
$P=\{2\}$. The invariant holds.

\emph{Inductive step.} Assume the odometer state is correct for $n$.

Let $m=n+1$. Update each residue $r_p(n)$ to $r_p(m)=(r_p(n)+1)\bmod p$. Two cases arise:

\begin{enumerate}
  \item \textbf{Composite case.} If some $p \in P$ with $p \leq \sqrt{m}$ has $r_p(m)=0$, then
  $p \mid m$. Repeated wraps reveal $\nu_p(m)$, and after dividing out all such prime powers,
  the cofactor is either $1$ or has only larger prime divisors. Since $P$ contains all primes
  $\leq \sqrt{m}$, any remaining cofactor $>1$ must be prime $> \sqrt{m}$ and thus $m$ itself.
  Hence $\sigma(m)$ is computed exactly.

  \item \textbf{Prime case.} If no $p \in P$ with $p \leq \sqrt{m}$ divides $m$, then $m$ has
  no smaller prime factor. Therefore $m$ is prime. Append $m$ to $P$, initialize its residue,
  and set $\sigma(m)=(0,0,\dots,0,1)$: the one-hot vector on the new axis.
\end{enumerate}

In both cases the odometer state is updated consistently and the invariant extends to $m$.
Thus by induction the algorithm correctly generates $\sigma(n)$ for all $n \geq 2$.
\end{proof}

\begin{corollary}[Canonical Carry Certificate]
For every $k \geq 1$, the successor step
\[
p_{k+1}-1 \in S_k, \qquad p_{k+1} \notin S_k
\]
forces $\sigma(p_{k+1})=(0,0,\dots,0,1)$. In other words, primality of $p_{k+1}$ is certified
structurally by the canonical carry, without need for external verification.
\end{corollary}

This theorem establishes the Prime Odometer as both a generative law and a certifying mechanism:
primes appear as the inevitable one-hot carries of arithmetic.

%--------
\section{Comparison with Classical Sieves}

The Prime Odometer provides a constructive law for prime emergence. To clarify its significance, we
contrast it with classical sieve methods, particularly the Sieve of Eratosthenes.

\subsection{The Sieve of Eratosthenes}

The sieve, devised in antiquity, remains a conceptual cornerstone. To enumerate primes up to $N$:

\begin{enumerate}
  \item Begin with the list $\{2,3,\dots,N\}$.
  \item Iteratively select the next unused number $p$; mark all multiples of $p$ as composite.
  \item Continue until all numbers are either marked or declared prime.
\end{enumerate}

This method is \emph{eliminative}: primes are defined by exclusion, emerging as survivors after
composites are marked. The sieve is efficient, with complexity $O(N \log \log N)$, and underpins
modern segmented and wheel-optimized sieves.

\subsection{The Prime Odometer}

By contrast, the odometer is \emph{constructive}:

\begin{itemize}
  \item It advances $n \mapsto n+1$ sequentially, updating the residue counters of known primes.
  \item When redistribution suffices, $n+1$ factors over existing axes and is composite.
  \item When redistribution fails, the successor vector is forced to $(0,0,\dots,0,1)$:
        a new prime axis is created, and $n+1$ is prime.
\end{itemize}

Whereas Eratosthenes removes composites to reveal primes, the odometer generates successors and
primes appear as structural necessities.
\footnote{Algorithmically, the Odometer realizes an incremental trial-division sieve by known primes up to $\sqrt{n}$, a method well established in classical number theory texts such as Hardy and Wright~\cite{hardywright} and Crandall and Pomerance~\cite{crandallpomerance}. Its novelty lies in the reframing: representing the process in PE-space as canonical carries yields a constructive law of prime emergence.}


\subsection{Duality of Odometers}

The contrast mirrors positional vs.\ canonical counting:

\begin{itemize}
  \item In base-$B$, carries occur at constant rate: every trailing string of $(B-1)$ digits forces
        a positional carry (e.g.\ $999 \mapsto 1000$).
  \item In PE-space, carries occur exactly at primes: rare, sparse events of rate $\sim 1/\log n$.
\end{itemize}

Thus Eratosthenes’ sieve is the archetypal \emph{eliminative sieve}, while the Prime Odometer is
the archetypal \emph{generative sieve}. One defines primes as what remains when composites are
marked; the other defines primes as what emerges when carries are forced.

\subsection{Resource Profiles}

\begin{itemize}
  \item The sieve of Eratosthenes requires $O(N)$ storage to mark integers up to $N$.
  \item The odometer requires only $O(\pi(\sqrt{N}))$ residue counters, growing with the number of
        primes up to $\sqrt{N}$.
\end{itemize}

Both methods are theoretically complete, but the odometer frames primes not as anomalies to be
detected, but as the natural milestones of arithmetic progression.

\subsection{Conceptual Significance}

The odometer provides a \emph{positive definition of primality}. Rather than saying ``a prime has
no divisors,'' we can now say: \emph{a prime is the inevitable one-hot successor state forced when
redistribution in PE-space fails}. This is not only an algorithmic advance but a conceptual shift,
placing primes as the constructive carries of arithmetic, dual to the digit carries of positional
systems.

%--------

\section{Implications}

The Prime Odometer reframes primality from a negative property to a constructive law. Several
implications follow, both mathematical and conceptual.

\subsection{Positive Definition of Primes}

Classically, primes are defined negatively: an integer $p > 1$ is prime if it has no divisors other
than $1$ and itself. The odometer provides a positive definition:

\begin{quote}
A prime is an integer $m$ such that $\sigma(m) = (0,0,\dots,0,1)$, the one-hot vector created
when redistribution across existing prime axes fails.
\end{quote}

In this view, primality is not absence of divisibility but presence of inevitability: the creation of
a new axis.

\subsection{Inductive Certification}

Because the odometer maintains residues for all primes $\leq \sqrt{n}$, it generates $\sigma(n+1)$
correctly by induction. This provides a new style of proof:

\begin{itemize}
  \item Base case: $\sigma(2) = (1,0,0,\dots)$.
  \item Inductive step: update residues; either factor $n+1$ over $P$, or force a new axis.
  \item Thus, by induction, $\sigma(n)$ is correct for all $n$.
\end{itemize}

Primality is certified not by external test but by structural necessity.

\subsection{Generative Sieve}

The odometer is not a cataloguer of primes up to $N$; it is a generator of successors. In this sense
it functions as a \emph{generative sieve}:

\begin{itemize}
  \item It advances incrementally, producing $\sigma(n)$ at each tick.
  \item Composites arise naturally from redistribution over existing axes.
  \item Primes arise inevitably as canonical carries.
\end{itemize}

This contrasts with traditional sieves, which are bulk eliminative methods.

\subsection{Duality with Positional Systems}

The odometer clarifies a symmetry:

\begin{itemize}
  \item In positional systems, carries occur constantly (rate $1/(B-1)$), enforcing digit rollover.
  \item In PE-space, carries occur sparsely (rate $\sim 1/\log n$), enforcing axis creation.
\end{itemize}

Thus primes are revealed as the \emph{canonical carries} of arithmetic: the sparse but necessary
events that extend dimensionality.

\subsection{Philosophical Perspective}

The odometer shifts the epistemology of primality:

\begin{itemize}
  \item From \emph{detection} (is $n$ prime?) to \emph{construction} (primes emerge when they must).
  \item From \emph{anomaly} (exceptions in the sequence) to \emph{inevitability} (structural law).
  \item From \emph{negative definition} (lack of divisors) to \emph{positive definition}
        (forced one-hot successor).
\end{itemize}

This reconceptualization elevates the odometer beyond an algorithm: it is a theoretical lens that
positions primes as structural inevitabilities of counting itself.

%--------

\section{Outlook and Open Questions}

The Prime Odometer establishes a generative law of primality. Yet many questions remain open,
both mathematical and practical. We highlight several directions for further study.

\subsection{Prime Gaps and Next-Prime Distance}

The odometer identifies primes at the exact moment redistribution fails, but it does not
predict \emph{how far ahead} the next prime lies. The length of prime gaps remains encoded in the
interplay of residue counters, but an explicit formula has not yet been extracted. A natural open
problem is:

\begin{quote}
Can the odometer state at $n$ be used to bound or predict the distance to the next prime?
\end{quote}

If so, this would provide a constructive mechanism for understanding prime gaps directly in
PE-space.

\subsection{Truncated Odometers and Engineering Approximations}

In theory, the odometer requires residues for all primes $\leq \sqrt{n}$. In practice, this is
memory-intensive at scale. Classical engineering techniques such as wheels and smallest-prime-factor
tables approximate the full odometer state with bounded resources. A research direction is to
analyze:

\begin{quote}
When and how can truncated odometers preserve correctness guarantees while reducing cost?
\end{quote}

This bridges the pure theory with practical implementation.

\subsection{Analytic Connections}

The odometer frames prime emergence as carries of rate $\sim 1/\log n$. This is in harmony with
the Prime Number Theorem, which states that
\[
\pi(x) \sim \frac{x}{\log x}.
\]
A fruitful direction is to relate odometer dynamics explicitly to analytic objects such as
Chebyshev’s function $\psi(x)$ and to study whether the odometer yields new insights into error
terms in prime counting.

\subsection{Complexity and Performance}

The asymptotic complexity of the odometer, compared with sieves, remains to be explored in detail.
While the state size grows as $\pi(\sqrt{n})$, incremental updates may amortize efficiently.
Precise complexity analyses and optimizations are natural future work.

\subsection{Broader Emergence Principle}

The odometer provides a clean arithmetic instantiation of a broader principle:

\begin{quote}
Irreducible structures emerge when redistribution fails.
\end{quote}

This principle has already been connected to physics, complexity science, and information theory in
prior work. The odometer now grounds this axiom in a generative arithmetic law, suggesting fertile
cross-disciplinary analogies remain to be drawn.

\subsection{Summary of Open Questions}

\begin{itemize}
  \item Can prime gaps be bounded or predicted from odometer state?
  \item How can truncated odometers be engineered efficiently without losing rigor?
  \item What new connections to analytic number theory emerge from the carry law?
  \item What is the precise computational complexity of the odom
\end{itemize}

%--------

\section{Conclusion}

We have introduced the \emph{Prime Odometer}, a constructive successor law in Prime Exponent
Space that generates primes as the inevitable one-hot carries of arithmetic. Rather than defining
primes negatively---as numbers lacking divisors---the odometer defines them positively: they are
the states that \emph{must} arise when redistribution across existing axes fails.

The Odometer Theorem establishes correctness by induction: starting from $\sigma(2)$, each tick
$n \mapsto n+1$ updates residue counters, factors composites over known primes, and forces a new
axis precisely when $n+1$ is prime. Primality is thus certified structurally, without external
tests.

This reframes primality in three key ways:

\begin{itemize}
  \item \textbf{Constructive definition:} a prime is the one-hot successor vector forced by failure
        of redistribution.
  \item \textbf{Generative sieve:} the odometer produces primes sequentially, rather than leaving
        them as remainders after composites are eliminated.
  \item \textbf{Canonical carry:} primes are the sparse but necessary carries of PE-space, dual to
        the frequent digit carries of positional systems.
\end{itemize}

Conceptually, the odometer complements and completes the sieve of Eratosthenes: together they form
a duality of prime generation, one eliminative and one constructive. Practically, the odometer
suggests new pathways for incremental prime generation and analysis of prime gaps. Theoretically,
it elevates primes from anomalies to inevitabilities: the canonical carries that arithmetic cannot
avoid.

In this sense, the Prime Odometer is more than an algorithm. It is a law of emergence, revealing
that primes are not random accidents scattered along the number line, but structural necessities of
counting itself.

%--------

\section*{External Reviews and Strategic Positioning}

Independent reviewers emphasized that the central novelty of the Prime Odometer lies not in its raw mechanics—which are algorithmically equivalent to classical incremental sieves—but in its conceptual and pedagogical reframing. The Odometer reframes prime generation as a \emph{positive}, \emph{constructive}, and \emph{inevitable} process in Prime Exponent Space (PE-space). Primes appear as \emph{canonical carries}, rather than as survivors of elimination.

Key points from the reviews:

\begin{itemize}
  \item The algorithm is mechanically equivalent to trial-division with residue counters, but its \textbf{interpretive reframing} is original, powerful, and pedagogically valuable.
  \item The duality between \textbf{eliminative sieves} (Eratosthenes) and the \textbf{generative sieve} (Odometer) is central, and reviewers found this conceptual contrast compelling.
  \item The Odometer provides a \textbf{positive definition of primality}: a prime is the successor state forced when redistribution in PE-space fails.
  \item While not an algorithmic breakthrough, the Odometer offers a new \textbf{mental model} of why primes emerge, likely to influence teaching, exposition, and interdisciplinary analogy.
\end{itemize}

Reviewers also stressed the strategic sequencing of publications. Publishing \emph{The Prime Odometer} first grounds the PE-space framework in a provably correct, non-controversial setting. Only after this foundation is established should the more heuristic work on rupture dynamics and the $\Phi$-detector be introduced. This order mitigates skepticism and frames the rupture model as a natural extension rather than a speculative leap.

\paragraph{Relation to prior art.}
The underlying mechanism of the Odometer is algorithmically equivalent to classical incremental sieves and trial-division methods, which are well documented in standard references such as Hardy and Wright~\cite{hardywright}, Cohen~\cite{cohen}, and Crandall and Pomerance~\cite{crandallpomerance}. Its contribution lies not in asymptotic improvement, but in its \emph{reframing}: the Odometer renders primes as canonical carries in PE-space, providing a constructive law and a positive definition of primality. This situates the work alongside, but conceptually distinct from, eliminative sieves and their modern refinements.

%--------

\section*{Appendix A: Pseudocode (Prime Odometer)}

\subsection*{A.1 Minimal Odometer (Decision-Only, Factor-Free)}

% This variant decides prime/composite and enumerates primes incrementally.
% It maintains residues mod p for all discovered primes p \le sqrt(n).

\noindent\textbf{State}
\begin{itemize}
  \item $P$ : list of discovered primes, initially $[2]$.
  \item $r$ : dictionary of residues $r[p] \equiv n \pmod p$ for each $p \in P$.
  \item $n$ : current integer (start at $n=2$).
\end{itemize}

\noindent\textbf{Tick Procedure} (advance to $m=n+1$)
\begin{verbatim}
function TICK(n, P, r):
    m = n + 1

    # 1) Increment residues
    for p in P:
        r[p] = (r[p] + 1) % p

    # 2) Test divisibility up to sqrt(m) via residues
    composite = False
    for p in P:
        if p*p > m: break
        if r[p] == 0:
            composite = True
            break

    if composite:
        # m is composite; factors may be recovered separately if desired.
        return (m, "composite", P, r)

    # 3) Otherwise m is prime: append to prime list and initialize its residue
    P.append(m)
    r[m] = 0  # since m ≡ 0 (mod m)
    return (m, "prime", P, r)
\end{verbatim}

\noindent\textbf{Driver (enumerate up to a bound \(N\))}
\begin{verbatim}
P = [2]
r = {2: 2 % 2}  # i.e., 0
n = 2
yield 2

while n < N:
    (m, tag, P, r) = TICK(n, P, r)
    if tag == "prime":
        yield m
    n = m
\end{verbatim}

\noindent\emph{Notes.} This minimal odometer:
\begin{itemize}
  \item never re-factors $m=n+1$;
  \item decides primality using only residues for $p \le \sqrt{m}$;
  \item enumerates primes in increasing order.
\end{itemize}

\subsection*{A.2 Extended Odometer (Optional Valuations via \(p^t\) Stacks)}

% This variant additionally recovers valuations ν_p(m) by tracking residues mod p^t.
% It still avoids refactoring m; ν_p(m) is read off from carry-depth wraps.

\noindent\textbf{Additional State}
\begin{itemize}
  \item $R$ : dictionary-of-dictionaries $R[p][t] \equiv n \pmod{p^t}$ for $t=1,\dots,T_p$ (small).
\end{itemize}

\noindent\textbf{Tick Procedure with Valuations}
\begin{verbatim}
function TICK_WITH_VALUATIONS(n, P, r, R, Tpow):
    m = n + 1

    # 1) Increment residues mod p and mod p^t (for small t)
    for p in P:
        r[p] = (r[p] + 1) % p
        for t in 2..Tpow[p]:
            mod_pt = p**t
            R[p][t] = (R[p][t] + 1) % mod_pt

    # 2) Compute ν_p(m) from carry-depth wraps (optional)
    nu = {}            # valuations ν_p(m)
    composite = False
    for p in P:
        if p*p > m: break
        if r[p] == 0:
            composite = True
            # detect depth by scanning highest t where residue wrapped to 0
            tmax = 1
            for t in 2..Tpow[p]:
                if R[p][t] == 0:
                    tmax = t
                else:
                    break
            nu[p] = tmax

    if composite:
        # cofactor can be inferred as m / prod p^{ν_p} if desired
        return (m, "composite", nu, P, r, R)

    # 3) Otherwise m is prime: append to primes and initialize residues
    P.append(m)
    r[m] = 0
    R[m] = {}
    for t in 2..Tpow_default:
        R[m][t] = 0
    return (m, "prime", {m:1}, P, r, R)
\end{verbatim}

\noindent\emph{Remarks.}
\begin{itemize}
  \item The minimal variant suffices for \emph{primality decision and enumeration}.
  \item The extended variant recovers \(\nu_p(m)\) by reading carry-depth wraps in \(R[p][t]\),
        still without refactoring \(m\).
  \item If a full \(\sigma(m)\) vector is required, the cofactor \(R\_m = m / \prod p^{\nu_p(m)}\) can be
        computed arithmetically; when the decision branch declares \(m\) prime, this cofactor equals \(m\)
        and the one-hot vector is certified.
\end{itemize}

%--------
\section*{Appendix B: Remark on Additive–Multiplicative Enantiomorphism}

A structural duality is worth noting. In positional base-$B$ systems,
the successor map $n \mapsto n+1$ is local and trivial—implemented by
digit increments with constant-rate carries—while multiplication is
nonlinear and comparatively costly. In Prime Exponent Space (PE-space),
the situation is reversed: multiplication and division reduce to vector
addition and subtraction on $\sigma(n)$, but the successor map is
globally nontrivial. Each step $n \mapsto n+1$ requires reconciling all
prime-power counters, and at primes this culminates in a canonical carry:
a new axis $(0,0,\dots,0,1)$.

Thus the two coordinate systems appear as enantiomorphic “hands” of
arithmetic: what is local in one is global in the other, and vice versa.
In both representations, carry events balance into a linear flux
($\psi(x) \sim x$ in PE-space, constant-rate digit carries in base-$B$),
suggesting a deeper invariant. We flag this as a potential unifying
principle—a carry–flux conservation law across additive and
multiplicative coordinates—whose full exploration we leave for future
work.

%--------
\bibliographystyle{plain}
\begin{thebibliography}{9}

\bibitem{hardywright}
G.H. Hardy and E.M. Wright. \textit{An Introduction to the Theory of Numbers}. Oxford University Press, 6th ed., 2008.

\bibitem{crandallpomerance}
R. Crandall and C. Pomerance. \textit{Prime Numbers: A Computational Perspective}. Springer, 2nd ed., 2005.

\bibitem{cohen}
H. Cohen. \textit{Number Theory, Volume I: Tools and Diophantine Equations}. Springer, 2nd ed., 2007.

\end{thebibliography}

\end{document}
